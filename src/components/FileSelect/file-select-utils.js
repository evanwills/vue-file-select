import mimeTypes from './mimeTypes';

export const dummyDispatch = (_eventName, _data) => {};

export const cloneFileDataItem = (file) => ({ ...file });

/**
 * Get list of allowed file types separated list of file extensions
 *
 * @param types Space separated list of file extensions
 *
 * @returns List of allowed file types user can upload
 */
export const getAllowedTypes = (types) => {
  /**
   * List of good file extensions
   *
   * @var {string[]}
   */
  const good = [];
  /**
   * List of allowed file type metadata objects
   */
  const output = [];
  const bad = [];
  const typeList = types.replace(/[\t\n\r\s :;|,]+/g, ' ').toLowerCase().trim().split(' ');

  if (typeList.length === 0) {
    return [];
  }

  const allowedMime = {};

  for (const _type of Object.keys(mimeTypes)) {
    allowedMime[mimeTypes[_type].mime] = mimeTypes[_type];
  }

  for (const _type of typeList) {
    const ext = _type.replace(/[^a-z0-9]+/, '').substring(0, 4);

    if (typeof mimeTypes[ext] !== 'undefined') {
      if (good.includes(ext) === false) {
        good.push(ext);
        output.push(mimeTypes[ext]);
      }
    } else if (typeof allowedMime[_type] !== 'undefined') {
      if (good.includes(allowedMime[_type].ext) === false) {
        good.push(allowedMime[_type].ext);
        output.push(allowedMime[_type]);
      }
    } else if (bad.includes(_type) === false) {
      bad.push(_type);
    }
  }

  if (good.length === 0) {
    // eslint-disable-next-line no-console
    throw new Error(
      'Bad file mime types specified in <file-upload> component: '
      + `"${bad.join('", "')}"`,
    );

  }

  return output;
};

export const resetPos = (file, index) => {
  file.pos = index;
  return file;
};

/**
 * Get the file size metadata of a file (based on the supplied file
 * sise in bytes)
 *
 * @param {number} bytes    File size in bytes
 * @param {number} decimals number of decimal points to return
 *
 * @returns {object}
 */
export const formatBytes = (bytes, decimals = 2) => {
  if (bytes === 0) {
    return '0 Bytes';
  }

  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

  const i = Math.floor(Math.log(bytes) / Math.log(k));
  const obj = {
    size: Math.round(parseFloat((bytes / (k ** i)))),
    full: `${parseFloat((bytes / (k ** i))).toFixed(dm)} ${sizes[i]}`,
    type: `${sizes[i]}`,
  };

  return obj;
};

/**
 * Check whether the type of the current file is allowed
 *
 * @param {File}  file  File to test for mime type validation
 * @param {Array} types Allowed types
 *
 * @returns {boolean} TRUE if the file type matches one of the
 *                    allowed file types. FALSE otherwise
 */
export const isValidFileType = (file, types) => (
  types.length === 0
  || typeof types.find((mime) => mime.mime === file.type) !== 'undefined'
);

/**
 * Convert human readable file size into bytes so it can be compared
 * to File.size values
 *
 * @param humanSize Human readable file size
 *
 * @returns file size in Bytes
 */
export const humanFileSizeToBytes = (humanSize) => {
  const units = ['B', 'KB', 'MB', 'GB'];
  const bits = humanSize.match(/([0-9.]+)([KMG]?B)?/);
  const errorMsg = 'Invalid file size found. Could not convert '
    + `"${humanSize}" to Bytes`;

  if (bits === null) {
    // eslint-disable-next-line no-console
    throw new Error(errorMsg);
  }

  const num = parseFloat(bits[1]);
  const unit = (typeof bits[2] === 'string' && bits[2] !== '')
    ? bits[2]
    : 'B';

  const i = units.indexOf(unit);

  if (i > -1 && num > 0) {
    return Math.round(num * (1024 ** i));
  }

  // eslint-disable-next-line no-console
  throw new Error(errorMsg);
};

/**
 * Get a unique file name for a possibly default file name
 *
 * If file was generated by iOS camera it will always have a file
 * name of "image.jpg". If the file has this name add a timestamp to
 * the file name to make it unique.
 *
 * @param {File} file File whose name needs to be made unique
 *
 * @returns {string} Unique file name
 */
export const getUniqueFileName = (file) => {
  if (file instanceof File === false || typeof file.name !== 'string' || file.name.trim() === '') {
    throw new Error(
      'getUniqueFileName() expects only argument `file` to be an '
      + 'instance of File. with a non-empty file name',
    );
  }

  /**
   * List of known generic file names that need to be made unique
   *
   * This is a list of generic and unchanging file names generated by
   * device cameras when using the device camera for file upload,
   * rather than uploading an existing image file.
   *
   * @var {string[]} genericNames
   */
  const genericNames = ['image.jpg'];

  /**
   * @var {string} name File name to be made unique (if required)
   */
  const name = file[key].toLowerCase();

  if (genericNames.includes(name) === false) {
    // This is just a normal file with a normal file name
    return file.name;
  }

  // This is a known generic file name probably generated by an
  // iOS device camera. The device is clearly too stupid to give
  // the file a unique file name so we need to make the file name
  // unique.
  const bits = file[key].split('.', 2);

  return `${bits[0]}_${Date.now()}.${bits[1]}`;
};

export const getEventTypes = () => {
  return {
    'allcomplete': {
      dataType: 'boolean',
      description: 'Emitted when work on a single file is '
        + 'complete. Data will only be `TRUE` if there are no '
        + 'more files yet to complete processing.',
    },
    'complete': {
      dataType: 'AllCompleteEventData',
      description: 'Emitted when work on a single file is '
        + 'complete.',
    },
    'toomany': {
      dataType: 'ToomanyEventData',
      description: 'Emitted when work on a single file is '
        + 'complete but the total number of files selected is '
        + 'greater than allowed',
    },
    'toobig': {
      dataType: 'ToobigEventData',
      description: 'Emitted when work on a single file is '
        + 'complete but combined size of all the files is larger '
        + 'than allowed',
    },
    'oversize': {
      dataType: 'OversizeEventData',
      description: 'Emitted when work on a single file is '
        + 'complete but that file is larger than allowed for a '
        + 'single file',
    },
    'invalid': {
      dataType: 'InvalidEventData',
      description: 'Emitted when work on a single file is '
        + 'complete but the type of that file is not in the '
        + 'allowed list.',
    },
    'processing': {
      dataType: 'string',
      description: 'Emitted when work starts on file named in '
        + 'the data.',
    },
    'processcount': {
      dataType: 'number',
      description: 'Emitted when work starts on a batch of files',
    },
  }
};
